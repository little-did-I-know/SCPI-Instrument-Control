"""
Markdown report generator.

Generates human-readable Markdown reports that can be viewed in text editors,
converted to other formats, or committed to documentation repositories.
"""

from pathlib import Path
from typing import List
import matplotlib.pyplot as plt
import numpy as np

from siglent.report_generator.generators.base import BaseReportGenerator
from siglent.report_generator.models.report_data import (
    TestReport,
    TestSection,
    MeasurementResult,
    WaveformData,
)


class MarkdownReportGenerator(BaseReportGenerator):
    """Generator for Markdown format reports."""

    def __init__(self, include_plots: bool = True, plots_dir: str = "plots"):
        """
        Initialize Markdown generator.

        Args:
            include_plots: Whether to generate and include waveform plots
            plots_dir: Directory name for saving plot images (relative to report)
        """
        self.include_plots = include_plots
        self.plots_dir = plots_dir

    def get_file_extension(self) -> str:
        """Get file extension."""
        return ".md"

    def generate(self, report: TestReport, output_path: Path) -> bool:
        """
        Generate Markdown report.

        Args:
            report: Test report
            output_path: Path to save the report

        Returns:
            True if successful, False otherwise
        """
        if not self.validate_report(report):
            print("Report validation failed")
            return False

        try:
            # Create plots directory if needed
            output_path = Path(output_path)
            if self.include_plots:
                plots_path = output_path.parent / self.plots_dir
                plots_path.mkdir(parents=True, exist_ok=True)

            # Generate markdown content
            content = self._generate_content(report, output_path.parent)

            # Write to file
            with open(output_path, "w", encoding="utf-8") as f:
                f.write(content)

            return True

        except Exception as e:
            print(f"Failed to generate Markdown report: {e}")
            return False

    def _generate_content(self, report: TestReport, base_path: Path) -> str:
        """Generate the complete markdown content."""
        lines = []

        # Title and metadata
        lines.append(f"# {report.metadata.title}")
        lines.append("")
        lines.append(self._generate_metadata_section(report))
        lines.append("")

        # Overall result
        overall_result = report.overall_result or report.calculate_overall_result()
        result_emoji = "✅" if overall_result == "PASS" else "❌" if overall_result == "FAIL" else "ℹ️"
        lines.append(f"## Overall Result: {result_emoji} {overall_result}")
        lines.append("")

        # Executive summary (if available)
        if report.executive_summary:
            lines.append("## Executive Summary")
            lines.append("")
            lines.append(report.executive_summary)
            lines.append("")
            if report.ai_generated_summary:
                lines.append("*Summary generated by AI*")
                lines.append("")

        # Key findings
        if report.key_findings:
            lines.append("## Key Findings")
            lines.append("")
            for finding in report.key_findings:
                lines.append(f"- {finding}")
            lines.append("")

        # Sections
        for section in report.sections:
            lines.append(self._generate_section(section, base_path))
            lines.append("")

        # Recommendations
        if report.recommendations:
            lines.append("## Recommendations")
            lines.append("")
            for i, rec in enumerate(report.recommendations, 1):
                lines.append(f"{i}. {rec}")
            lines.append("")

        # Footer
        lines.append("---")
        lines.append("")
        lines.append(f"*Report generated on {report.metadata.test_date.strftime('%Y-%m-%d at %H:%M:%S')}*")
        if report.metadata.company_name:
            lines.append(f"*{report.metadata.company_name}*")
        lines.append("")

        return "\n".join(lines)

    def _generate_metadata_section(self, report: TestReport) -> str:
        """Generate metadata table."""
        lines = []
        meta = report.metadata

        lines.append("| Field | Value |")
        lines.append("|-------|-------|")
        lines.append(f"| **Technician** | {meta.technician} |")
        lines.append(f"| **Date** | {meta.test_date.strftime('%Y-%m-%d %H:%M:%S')} |")

        if meta.equipment_model:
            lines.append(f"| **Equipment** | {meta.equipment_model} |")
        if meta.equipment_id:
            lines.append(f"| **Equipment ID** | {meta.equipment_id} |")
        if meta.test_procedure:
            lines.append(f"| **Test Procedure** | {meta.test_procedure} |")
        if meta.project_name:
            lines.append(f"| **Project** | {meta.project_name} |")
        if meta.customer:
            lines.append(f"| **Customer** | {meta.customer} |")
        if meta.temperature:
            lines.append(f"| **Temperature** | {meta.temperature} |")
        if meta.humidity:
            lines.append(f"| **Humidity** | {meta.humidity} |")
        if meta.location:
            lines.append(f"| **Location** | {meta.location} |")

        return "\n".join(lines)

    def _generate_section(self, section: TestSection, base_path: Path) -> str:
        """Generate a section of the report."""
        lines = []

        lines.append(f"## {section.title}")
        lines.append("")

        if section.content:
            lines.append(section.content)
            lines.append("")

        # AI insights
        if section.ai_summary:
            lines.append("### AI Analysis")
            lines.append("")
            lines.append(section.ai_summary)
            lines.append("")

        if section.ai_insights:
            lines.append("### AI Insights")
            lines.append("")
            lines.append(section.ai_insights)
            lines.append("")

        # Waveforms
        if section.waveforms:
            lines.append("### Waveforms")
            lines.append("")
            for i, waveform in enumerate(section.waveforms):
                lines.append(self._generate_waveform_info(waveform, base_path, f"{section.title}_{i}"))
                lines.append("")

        # Measurements
        if section.measurements:
            lines.append("### Measurements")
            lines.append("")
            lines.append(self._generate_measurements_table(section.measurements))
            lines.append("")

        # FFT
        if section.include_fft and section.fft_frequency is not None:
            lines.append("### FFT Analysis")
            lines.append("")
            if self.include_plots:
                fft_plot_path = self._generate_fft_plot(
                    section.fft_frequency,
                    section.fft_magnitude,
                    base_path,
                    f"{section.title}_fft"
                )
                lines.append(f"![FFT Analysis]({fft_plot_path})")
            lines.append("")

        # Images
        if section.images:
            lines.append("### Images")
            lines.append("")
            for img_path in section.images:
                lines.append(f"![Image]({img_path})")
                lines.append("")

        return "\n".join(lines)

    def _generate_waveform_info(self, waveform: WaveformData, base_path: Path, name: str) -> str:
        """Generate waveform information and plot."""
        lines = []

        lines.append(f"#### {waveform.label}")
        lines.append("")

        # Generate plot if requested
        if self.include_plots:
            plot_path = self._generate_waveform_plot(waveform, base_path, name)
            lines.append(f"![{waveform.label}]({plot_path})")
            lines.append("")

        # Waveform info table
        lines.append("| Parameter | Value |")
        lines.append("|-----------|-------|")
        lines.append(f"| Sample Rate | {waveform.sample_rate / 1e6:.2f} MS/s |")
        lines.append(f"| Record Length | {waveform.record_length} samples |")

        if waveform.timebase:
            lines.append(f"| Timebase | {waveform.timebase * 1e6:.2f} µs/div |")
        if waveform.voltage_scale:
            lines.append(f"| Voltage Scale | {waveform.voltage_scale} V/div |")
        if waveform.probe_ratio:
            lines.append(f"| Probe Ratio | {waveform.probe_ratio}:1 |")

        # Statistics
        v_min = np.min(waveform.voltage_data)
        v_max = np.max(waveform.voltage_data)
        v_pp = v_max - v_min
        lines.append(f"| Peak-to-Peak | {v_pp:.4f} V |")
        lines.append(f"| Min | {v_min:.4f} V |")
        lines.append(f"| Max | {v_max:.4f} V |")

        return "\n".join(lines)

    def _generate_measurements_table(self, measurements: List[MeasurementResult]) -> str:
        """Generate measurements table."""
        lines = []

        lines.append("| Measurement | Value | Status | Criteria |")
        lines.append("|-------------|-------|--------|----------|")

        for meas in measurements:
            name = meas.name
            if meas.channel:
                name += f" ({meas.channel})"

            value = meas.format_value()

            status = meas.get_status_symbol()
            if meas.passed is True:
                status = "✅ PASS"
            elif meas.passed is False:
                status = "❌ FAIL"
            else:
                status = "—"

            criteria = []
            if meas.criteria_min is not None:
                criteria.append(f"min: {meas.criteria_min:.6g} {meas.unit}")
            if meas.criteria_max is not None:
                criteria.append(f"max: {meas.criteria_max:.6g} {meas.unit}")
            criteria_str = "<br>".join(criteria) if criteria else "—"

            lines.append(f"| {name} | {value} | {status} | {criteria_str} |")

        return "\n".join(lines)

    def _generate_waveform_plot(self, waveform: WaveformData, base_path: Path, name: str) -> str:
        """Generate and save waveform plot."""
        plots_path = base_path / self.plots_dir
        plots_path.mkdir(parents=True, exist_ok=True)

        filename = f"{name.replace(' ', '_')}.png"
        filepath = plots_path / filename

        fig, ax = plt.subplots(figsize=(10, 4))
        ax.plot(waveform.time_data * 1e6, waveform.voltage_data, color=waveform.color or "#1f77b4", linewidth=0.5)
        ax.set_xlabel("Time (µs)")
        ax.set_ylabel("Voltage (V)")
        ax.set_title(waveform.label)
        ax.grid(True, alpha=0.3)

        plt.tight_layout()
        plt.savefig(filepath, dpi=150, bbox_inches="tight")
        plt.close(fig)

        return f"{self.plots_dir}/{filename}"

    def _generate_fft_plot(self, frequency: np.ndarray, magnitude: np.ndarray, base_path: Path, name: str) -> str:
        """Generate and save FFT plot."""
        plots_path = base_path / self.plots_dir
        plots_path.mkdir(parents=True, exist_ok=True)

        filename = f"{name.replace(' ', '_')}_fft.png"
        filepath = plots_path / filename

        fig, ax = plt.subplots(figsize=(10, 4))
        ax.plot(frequency / 1e6, magnitude, color="#ff7f0e", linewidth=0.5)
        ax.set_xlabel("Frequency (MHz)")
        ax.set_ylabel("Magnitude (dB)")
        ax.set_title("FFT Analysis")
        ax.grid(True, alpha=0.3)

        plt.tight_layout()
        plt.savefig(filepath, dpi=150, bbox_inches="tight")
        plt.close(fig)

        return f"{self.plots_dir}/{filename}"
